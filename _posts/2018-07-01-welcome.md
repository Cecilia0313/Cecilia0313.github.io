---
title: Bernstein-Vazirani Algorithm
tags: Quantum Computing Algorithm
mathjax: true
---

Question: For function
$$f(\{x_0,x_1,x_2,...\}) \rightarrow 0 \textrm{ or } 1 \textrm{ where } x_n \textrm{ is }0 \textrm{ or } 1$$
Form: $f(x) = s \cdot x \, \text{(mod 2)}$，给定x，得到f(x)，求s的值。

Steps:

1. Initiation |0⟩⊗n  state, and output qubit
    to  |−⟩ . 
2. Hardmard Operator for Input Register。
3. Measurement to Output Register。
    
 For hardmard operators:
$$|a\rangle \xrightarrow{H^{\otimes n}} \frac{1}{\sqrt{2^n}} \sum_{x\in \{0,1\}^n} (-1)^{a\cdot x}|x\rangle.$$


我们对 $|00\dots 0\rangle$ 使用n Hadamard gates得到量子叠加态:

$$|00\dots 0\rangle \xrightarrow{H^{\otimes n}} \frac{1}{\sqrt{2^n}} \sum_{x\in \{0,1\}^n} |x\rangle$$

$(-1)^{a\cdot x}=0$ , since $a=0,$ and thus $(-1)^{a\cdot x} = 1$.

之后，我们作用$f_{s}$函数。这里我们的ouput初始状态a为$|{-}\rangle$.
 - 若f(x) = 1，$|a \oplus f(x)\rangle = -|{-}\rangle$ 
 - 若f(x) = 0，$|a \oplus   f(x)\rangle = |{-}\rangle$

$$|x \rangle \xrightarrow{f_s} (-1)^{s\cdot x} |x \rangle$$




$$|00\dots 0\rangle \xrightarrow{H^{\otimes n}} \frac{1}{\sqrt{2^n}} \sum_{x\in \{0,1\}^n} |x\rangle \xrightarrow{f_a} \frac{1}{\sqrt{2^n}} \sum_{x\in \{0,1\}^n} (-1)^{a\cdot x}|x\rangle$$


由于量子计算是可逆的，我们再使用Hardmard Gate便可以得到a。

$$\frac{1}{\sqrt{2^n}} \sum_{x\in \{0,1\}^n} (-1)^{a\cdot x}|x\rangle \xrightarrow{H^{\otimes n}} |a\rangle$$

---
**Coding**
```python
# initialization
import matplotlib.pyplot as plt
import numpy as np

# importing Qiskit
from qiskit import IBMQ, Aer
from qiskit.providers.ibmq import least_busy
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, transpile, assemble

# import basic plot tools
from qiskit.visualization import plot_histogram

n = 3 # number of qubits used to represent s
s = '011'   # the hidden binary string

# We need a circuit with n qubits, plus one auxiliary qubit
# Also need n classical bits to write the output to
bv_circuit = QuantumCircuit(n+1, n)

# put auxiliary in state |->
bv_circuit.h(n)
bv_circuit.z(n)

# Apply Hadamard gates before querying the oracle
for i in range(n):
    bv_circuit.h(i)
    
# Apply barrier 
bv_circuit.barrier()

# Apply the inner-product oracle
s = s[::-1] # reverse s to fit qiskit's qubit ordering
for q in range(n):
    if s[q] == '0':
        bv_circuit.i(q)
    else:
        bv_circuit.cx(q, n)
        
# Apply barrier 
bv_circuit.barrier()

#Apply Hadamard gates after querying the oracle
for i in range(n):
    bv_circuit.h(i)

# Measurement
for i in range(n):
    bv_circuit.measure(i, i)

bv_circuit.draw()

 use local simulator
qasm_sim = Aer.get_backend('qasm_simulator')
shots = 1024
qobj = assemble(bv_circuit)
results = qasm_sim.run(qobj).result()
answer = results.get_counts()

plot_histogram(answer)
```
